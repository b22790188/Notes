---
date : 2023-05-15 23:53
alias : []
---

---

## Background

Code需要被放在memory中等待執行，但整個program卻很少被使用到。
+ Error code
+ unusual routines, large data structures

Consider ability to execute partially-loaded program
+ Program不會受到實體記憶體限制，因為使用者可以自己寫一個更大的virtual address space來存放
+ 每個program花費更少的記憶體 -> 同時間有更多program可以執行
+ less I/O needed to load or swap programs into memory -> each user program runs faster

## Virtual Memory

Separation of user logical memory from physical memory

+ 是一種可以讓process執行時，不用完全都在memory中，只需要部份的process
+ Allowing easier programming and larger name space
+ Logical address space can therefore be much larger than physical space
+ Allows address spaces to be shared by several processe
+ Allows for more efficient process creation
+ More programs running concurrently
+ Less I/O needed to load or swap processes

`Virtual address space` :  logical view of how process is stored in memory
`Virtual address` : address generated by CPU , must be translated to physical address later before it used 

+ 通常從0開始，且是連續的address直到空間盡頭
	+ MMU負責maping logical to physical
+ Physical memory organized in page frames
+ 可以透過`demand paging`或`demand segmentation`來實作

### Virtual-address Space

設計上通常會讓stack從`max logical address` grow `down`，而heap則是grow `up` 
+ 在stack跟heap之間的就是`hole` ，也是`sparse address space`
	+ 可以留有空間供stack跟heap成長
	+ 或者將這個區塊用來放DLLs
+ 最大化空間使用 ->  因為中間都只會有一個hole，不會造成external fragmentation
+ 只有當stack或heap變大的時候，才會再要physical memory

### Demand Paging

只將需要的部分載入記憶體中，而不是整個program

+ Basic Concepts
	+ 因為在run time的時候有些page在memory中，有些在secondary storage中
		+ 利用valid bit來判別
			+ valid -> 表示page legal且在memory中
			+ invlid -> 表示page在secondary storage中

+ Access到invalid page時
	+ 造成page fault
	+ Page Fault Handling
		1. 先check process 的 internal table ，來決定這個reference是不是valid access
		2. 不是 -> abort , 是但不在記憶體中 -> step3
		3. 從free frame list中找到free frame
		4. 從secondary storage讀取該page並分配給剛剛找的frame
		5. 當operation完成，修改internal table，page table，來表示該page已經在memory中
		6. 重啟剛剛被trap打斷的instruction，就可以存取到page

+ Aspect
	+ Extreme case
		+ no page in memory
			+ page fault everytime until no fault -> bad performance
		 + 根據理論研究不太可能發生，因為program通常有locality of reference(記憶體附近的空間通常很快會被存取)

+ Hardware Support
	+ Page table with valid bit
	+ Secondary storage
	+ Instruction restart!!!!!

### Free-Frame List

一個存放free frame位置的list
+ OS allocate free frame using `zero-fill-on-demand`
	+ 在frame被分配以前，保持frame的內容清空
	+ When OS startup ，all availale memory is placed on free frame list

#### Demand Paging Optimization

+ Overall use of Swap space
	+ I/O to swap is faster than that to file system
+ Copy entire process image to swap space
	+ Then page in and out of swap
+ Demand page in from program binary on disk, but discard rather than paging out when freeing frame(p19)!!!
	+ anonymous memory
	+ modified in memory but not yet written back to file system

### Copy-on-Write

允許parent跟child可以share same page in memory

+ 當child要修改page C時，OS會去要一個free frame而且copy一份page C的內容讓child修改
![[Pasted image 20230515234354.png]]

+ vfork

### Page Replacement

Prevent over-allocationof memory by modifying page-fault service routine to include page replacement
+ modify(dirty) bit
	+ only modified page are written to disk
+ Page replacement comple  separation
	+ large virtual memory can be provided on a smaller physical memory

#### Basic Page Replacement

1. 在disk中找到想要的page位置
2. 找freeframe
	+ 如果有，就用該freeframe
	+ 沒有，利用replacement algorithm 挑選victim並替換，再將victim frame寫回disk(如果modified(dirty)) 
3. 將page分配到freeframe，更新page table and frame table
4. Continue process，藉由重啟instruction

+ Replacement algorithm
	+ Frame-allocation determines
		+ 一個process需要多少frame
		+ 哪個frame要被替換
	+ Page-replacement algorithm
		+ 要能有最低的page-fault rate
+ Evaluate
	+ 給定一個string ，計算page fault
	+ 字串只包含pagenumber
		